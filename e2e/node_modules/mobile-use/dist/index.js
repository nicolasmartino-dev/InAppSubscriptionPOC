var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ADBClient: () => ADBClient,
  mobileUse: () => mobileUse
});
module.exports = __toCommonJS(index_exports);
var import_ai2 = require("ai");
var import_zod2 = require("zod");

// src/adb_client.ts
var import_child_process = require("child_process");
var import_util = require("util");

// src/ui_dump_parser.ts
var import_fast_xml_parser = require("fast-xml-parser");
function parseUiDump(xmlDump) {
  const options = {
    ignoreAttributes: false,
    attributeNamePrefix: "",
    parseAttributeValue: true,
    isArray: (name) => name === "node"
  };
  const parser = new import_fast_xml_parser.XMLParser(options);
  const parsed = parser.parse(xmlDump);
  if (parsed.hierarchy && parsed.hierarchy.node && parsed.hierarchy.node[0]) {
    return simplifyNode(parsed.hierarchy.node[0]);
  }
  return { type: "root", clickable: false, bounds: "[0,0][0,0]" };
}
function hasContent(str) {
  return typeof str === "string" && str !== "";
}
function simplifyNode(node) {
  const element = {
    type: getElementType(node),
    clickable: node.clickable === "true",
    bounds: node.bounds || "[0,0][0,0]"
  };
  if (hasContent(node.text)) {
    element.text = node.text;
  }
  if (hasContent(node["content-desc"])) {
    element.desc = node["content-desc"];
  }
  if (hasContent(node["resource-id"])) {
    const idParts = node["resource-id"].split("/");
    element.id = idParts[idParts.length - 1];
  }
  if (node.node && node.node.length > 0) {
    if (shouldCollapseContainer(node)) {
      element.children = flattenChildren(node.node);
    } else {
      const meaningfulChildren = node.node.filter((child) => isMeaningfulNode(child)).map((child) => simplifyNode(child));
      if (meaningfulChildren.length > 0) {
        element.children = meaningfulChildren;
      }
    }
  }
  return element;
}
function shouldCollapseContainer(node) {
  return !hasContent(node.text) && !hasContent(node["content-desc"]) && node.clickable !== "true" && node.scrollable !== "true" && !hasContent(node["resource-id"]) && (node.class?.includes("Layout") || node.class?.includes("ViewGroup"));
}
function flattenChildren(nodes) {
  let result = [];
  for (const child of nodes) {
    if (shouldCollapseContainer(child) && child.node) {
      result = result.concat(flattenChildren(child.node));
    } else if (isMeaningfulNode(child)) {
      result.push(simplifyNode(child));
    }
  }
  return result;
}
function isMeaningfulNode(node) {
  if (node.clickable === "true" || node.scrollable === "true") {
    return true;
  }
  if (hasContent(node.text) || hasContent(node["content-desc"])) {
    return true;
  }
  if (hasContent(node["resource-id"])) {
    return true;
  }
  if (node.node && node.node.length > 0) {
    return node.node.some((child) => isMeaningfulNode(child));
  }
  return false;
}
function getElementType(node) {
  const className = node.class || "";
  if (className.includes("Button")) return "button";
  if (className.includes("EditText")) return "input";
  if (className.includes("TextView")) return "text";
  if (className.includes("ImageView")) return "image";
  if (className.includes("CheckBox")) return "checkbox";
  if (className.includes("RadioButton")) return "radio";
  if (className.includes("RecyclerView") || className.includes("ListView"))
    return "list";
  if (className.includes("CardView")) return "card";
  if (hasContent(node["resource-id"]) && (node["resource-id"].includes("one") || node["resource-id"].includes("two") || node["resource-id"].includes("three") || node["resource-id"].includes("four") || node["resource-id"].includes("five") || node["resource-id"].includes("six") || node["resource-id"].includes("seven") || node["resource-id"].includes("eight") || node["resource-id"].includes("nine") || node["resource-id"].includes("zero") || node["resource-id"].includes("star") || node["resource-id"].includes("pound"))) {
    return "dialpad_button";
  }
  return "view";
}

// src/adb_client.ts
var import_os = require("os");
var import_path = require("path");
var import_fs = require("fs");
var import_sharp = __toESM(require("sharp"));
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var ANDROID_KEY_EVENTS = Object.entries({
  Enter: "KEYCODE_ENTER",
  Backspace: "KEYCODE_DEL",
  Tab: "KEYCODE_TAB",
  ArrowUp: "KEYCODE_DPAD_UP",
  ArrowDown: "KEYCODE_DPAD_DOWN",
  ArrowLeft: "KEYCODE_DPAD_LEFT",
  ArrowRight: "KEYCODE_DPAD_RIGHT",
  Escape: "KEYCODE_ESCAPE",
  Home: "KEYCODE_HOME",
  Back: "KEYCODE_BACK"
}).reduce((keyMap, [key, value]) => {
  keyMap[key.toLowerCase().trim()] = value;
  return keyMap;
}, {});
function getPotentialADBPaths() {
  const home = (0, import_os.homedir)();
  const platform = process.platform;
  const paths = [];
  if (platform === "win32") {
    paths.push(
      (0, import_path.join)(
        process.env.LOCALAPPDATA ?? "",
        "Android/Sdk/platform-tools/adb.exe"
      ),
      "C:\\Android\\sdk\\platform-tools\\adb.exe",
      (0, import_path.join)(home, "AppData/Local/Android/Sdk/platform-tools/adb.exe"),
      (0, import_path.join)(home, "AppData/Local/Android/android-sdk/platform-tools/adb.exe"),
      "C:\\Program Files\\Android\\android-sdk\\platform-tools\\adb.exe",
      "C:\\Program Files (x86)\\Android\\android-sdk\\platform-tools\\adb.exe"
    );
  } else if (platform === "darwin") {
    paths.push(
      "/usr/local/bin/adb",
      "/opt/homebrew/bin/adb",
      (0, import_path.join)(home, "Library/Android/sdk/platform-tools/adb"),
      "/Applications/Android Studio.app/Contents/sdk/platform-tools/adb"
    );
  } else if (platform === "linux") {
    paths.push(
      "/usr/local/bin/adb",
      "/usr/bin/adb",
      (0, import_path.join)(home, "Android/Sdk/platform-tools/adb"),
      "/opt/android-sdk/platform-tools/adb",
      "/opt/android-studio/sdk/platform-tools/adb"
    );
  } else {
    paths.push(
      "/usr/local/bin/adb",
      "/usr/bin/adb",
      (0, import_path.join)(home, "android-sdk/platform-tools/adb")
    );
  }
  if (process.env.ANDROID_HOME) {
    const adbExecutable = platform === "win32" ? "adb.exe" : "adb";
    paths.push((0, import_path.join)(process.env.ANDROID_HOME, "platform-tools", adbExecutable));
  }
  return paths;
}
var ADBClient = class {
  adbPath;
  constructor(options) {
    if (!options?.adbPath) {
      this.adbPath = this.getAdbPath();
    } else {
      this.adbPath = options.adbPath;
    }
  }
  getAdbPath() {
    const paths = getPotentialADBPaths();
    const validPath = paths.find((path) => (0, import_fs.existsSync)(path));
    if (!validPath) {
      throw new Error(
        "ADB not found. Please ensure Android SDK is installed and properly configured."
      );
    }
    return validPath;
  }
  async init() {
    await this.shell("settings put global window_animation_scale 0");
    await this.shell("settings put global transition_animation_scale 0");
    await this.shell("settings put global animator_duration_scale 0");
  }
  async screenshot() {
    const { stdout } = await execAsync(
      `"${this.adbPath}" exec-out screencap -p`,
      {
        encoding: "buffer",
        maxBuffer: 25 * 1024 * 1024
      }
    );
    return (0, import_sharp.default)(stdout).png({
      quality: 25
    }).toBuffer();
  }
  async screenSize() {
    const { stdout } = await this.execOut("wm size");
    const match = stdout.match(/Physical size: (\d+)x(\d+)/);
    if (!match) {
      throw new Error("Failed to get viewport size");
    }
    return {
      width: parseInt(match[1]),
      height: parseInt(match[2])
    };
  }
  async execOut(command) {
    return execAsync(`"${this.adbPath}" exec-out ${command}`);
  }
  async shell(command) {
    return execAsync(`"${this.adbPath}" shell ${command}`);
  }
  async doubleTap(coordinate) {
    const { x, y } = coordinate;
    await this.shell(`input tap ${x} ${y}`);
    return this.shell(`input tap ${x} ${y}`);
  }
  async tap(coordinate) {
    const { x, y } = coordinate;
    return this.shell(`input tap ${x} ${y}`);
  }
  async swipe(start, end, duration = 300) {
    const { x: startX, y: startY } = start;
    const { x: endX, y: endY } = end;
    return this.shell(
      `input swipe ${startX} ${startY} ${endX} ${endY} ${duration}`
    );
  }
  async type(text) {
    return this.shell(`input text "${text.replace(/["\s]/g, "\\ ")}"`);
  }
  async keyPress(key) {
    const androidKey = ANDROID_KEY_EVENTS[key.toLowerCase()];
    if (!androidKey) {
      throw new Error(`Unsupported key: ${key}`);
    }
    return this.shell(`input keyevent ${androidKey}`);
  }
  async listPackages(filter) {
    const { stdout } = await this.execOut(`pm list packages ${filter || ""}`);
    return stdout.split("\n").map((line) => line.replace("package:", "").trim()).filter(Boolean);
  }
  async openApp(packageName) {
    const result = await this.shell(`monkey -p ${packageName} 1`);
    if (result.stderr && result.stderr.includes("No activities found")) {
      throw new Error(`Failed to open app: ${result.stderr}`);
    }
    return result;
  }
  async dumpUI() {
    try {
      const { stdout } = await this.execOut(
        `uiautomator dump --compressed /dev/tty`
      );
      const ui = JSON.stringify(parseUiDump(stdout));
      return ui;
    } catch (error) {
      throw new Error(`Failed to get UI hierarchy: ${error.message}`);
    }
  }
};

// src/mobile_computer.ts
var import_ai = require("ai");
var import_zod = require("zod");

// src/utils.ts
var wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/mobile_computer.ts
var Coordinate = import_zod.z.array(import_zod.z.number());
var createMobileComputer = async (adbClient) => {
  const viewportSize = await adbClient.screenSize();
  const mobileComputer = (0, import_ai.tool)({
    description: `Mobile tool to perform actions on a mobile device.`,
    experimental_toToolResultContent(result) {
      return typeof result === "string" ? [{ type: "text", text: result }] : [{ type: "image", data: result?.data, mimeType: "image/png" }];
    },
    args: {
      displayHeightPx: viewportSize.height,
      displayWidthPx: viewportSize.width,
      displayNumber: 0
    },
    parameters: import_zod.z.object({
      action: import_zod.z.enum([
        "ui_dump",
        "tap",
        "swipe",
        "type",
        "press",
        "wait",
        "screenshot"
      ]).describe(`ui_dump: Get UI elements you can interact with for the current screen.
tap: Tap on the provided coordinate.
swipe: Swipe from start_coordinate to end_coordinate.
type: Type in the box.
press: Press mobile key or button.
screenshot: Take a screenshot of the current screen if UI dump is not helpful or where you need to see visuals. 
      `),
      coordinate: Coordinate.optional(),
      start_coordinate: Coordinate.optional(),
      end_coordinate: Coordinate.optional(),
      text: import_zod.z.string().optional(),
      duration: import_zod.z.number().optional()
    }),
    async execute({
      action,
      coordinate,
      text,
      duration,
      start_coordinate,
      end_coordinate
    }) {
      if (action === "ui_dump") {
        return adbClient.dumpUI();
      }
      if (action === "tap") {
        const [x, y] = coordinate;
        await adbClient.tap({ x, y });
        return adbClient.dumpUI();
      }
      if (action === "press") {
        await adbClient.keyPress(text);
        return adbClient.dumpUI();
      }
      if (action === "type") {
        await adbClient.type(text);
        return adbClient.dumpUI();
      }
      if (action === "screenshot") {
        const screenshot = await adbClient.screenshot();
        return {
          data: screenshot.toString("base64"),
          type: "image/png"
        };
      }
      if (action === "swipe") {
        const [start_coordinate_x, start_coordinate_y] = start_coordinate;
        const [end_coordinate_x, end_coordinate_y] = end_coordinate;
        await adbClient.swipe(
          { x: start_coordinate_x, y: start_coordinate_y },
          {
            x: end_coordinate_x,
            y: end_coordinate_y
          },
          duration
        );
        return adbClient.dumpUI();
      }
      if (action === "wait") {
        await wait(duration);
      }
    }
  });
  return mobileComputer;
};

// src/index.ts
var import_openai = require("@ai-sdk/openai");
var MobileUsePrompt = `You are an experienced mobile automation engineer. 
Your job is to navigate an android device and perform actions to fullfil request of the user.

<steps>
If the user asks to use a specific app in the request, open it before performing any other action.
Do not take ui dump more than once per action. If you think you don't need to take ui dump, skip it. Use it sparingly.
</steps>
`;
async function mobileUse({
  task,
  llm = (0, import_openai.openai)("gpt-4o")
}) {
  const adbClient = new ADBClient();
  await adbClient.init();
  const computer = await createMobileComputer(adbClient);
  const response = await (0, import_ai2.generateText)({
    messages: [
      {
        role: "system",
        content: MobileUsePrompt
      },
      {
        role: "user",
        content: task
      }
    ],
    model: llm,
    maxRetries: 3,
    maxSteps: 100,
    tools: {
      openApp: (0, import_ai2.tool)({
        parameters: import_zod2.z.object({
          name: import_zod2.z.string().describe(
            "package name of the app to open such as com.google.android.dialer"
          )
        }),
        description: "Open an on on android device.",
        async execute({ name }) {
          await adbClient.openApp(name);
          return `Successfull opened ${name}`;
        }
      }),
      listApps: (0, import_ai2.tool)({
        parameters: import_zod2.z.object({
          name: import_zod2.z.string().describe("Name of the package to filter.")
        }),
        description: "Use this to list packages.",
        async execute({ name }) {
          const list = await adbClient.listPackages(name);
          return list.join("\n");
        }
      }),
      computer
    }
  });
  return response;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ADBClient,
  mobileUse
});
